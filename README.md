# Dibs Integration Guide for Uniswap V2 Style Decentralized Exchanges

To integrate Dibs into a Uniswap V2 style decentralized exchange, you need to fulfill certain requirements for each of the following contracts, which are typically included in a Uniswap V2 DEX:

- Router
- PairFactory

For the Dibs system to function properly, meet the following requirements for each contract:

## Router

The router must have the following views:

- `factory`, which points to the PairFactory contract
- `getAmountsOut(uint amountIn, route[] memory routes) public view returns (uint[] memory amounts)`, which, given a swap route, returns all amountOuts. Note that the "route" struct is defined as follows: `{address from; address to; bool stable;}`
*note: set stable to false if you don't supoort it.*
- `weth()/wETH()`, which points to the wrapped native token of the chain. Please note that a Muon/ChainLink/pyth price feed for the native token
so for example for `for wBNB a pricefeed of BNB/USD needs to be available on Binance chain` or `for wFTM a pricefeed of FTM/USD needs to be available on Fantom chain` must be available on the chain.

Additionally, the router contract must emit Swap events with the following data:

- `event Swap(address indexed sender, uint256 amount0In, address tokenIn, address indexed to, bool stable, uint256 feeAmount);`

where "feeAmount" is the total fees generated by the swap. Afterward, you should transfer `feeAmount * MAX_DIBS_FEE_PERCENTAGE` to the Dibs contract.

When a swap utilizes a route with multiple hops, each `Pair` along the way will deduct a fee. To simplify the calculation of the fee, you can always base it on the input amount denominated by the input token. Here is an example: ```amount0In * getFee(stable)/SCALE```

If you are using a fee model that matches the following, you can exclude the `feeAmount` parameter and reduce gas consumption. Dibs can be configured to handle this calculations off-chain.

First, the `PairFactory` contract must have the following view:

- `getFee(bool stable) returns (uint256)`: this will return the fee percentage (assuming scale is 10000).

The fee amount in the Pair is calculated using the following formula:
```inputAmount * getFee(stable)/SCALE```

If you want to enable features such as rewards based on referrals for a specific pair, you must also include the route in the event:

- `event Swap(address indexed sender, uint amount0In, address _tokenIn, address indexed to, bool stable, uint256 feeAmount, route[] routes);`

## PairFactory

The `PairFactory` contract must emit a `PairCreated` event whenever a new pair is created:

- `event PairCreated(address indexed token0, address indexed token1, bool stable, address pair, uint256);`

It must have the following view:
- `dibs`: which points to the dibs contract address, this contract holds config such as referral percentages. Also this is the adderss that fees must be transferred to.
